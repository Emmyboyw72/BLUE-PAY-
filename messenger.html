<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <meta name="format-detection" content="telephone=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>Messenger ‚Ä¢ BluePay</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700;800&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --blue-primary: #1a73e8;
      --blue-dark: #0d47a1;
      --blue-light: #e8f0fe;
      --white: #ffffff;
      --text-gray: #2d2d2d;
      --border-gray: #e0e6ed;
      --bg-light: #fafbff;
      --red-badge: #ea4335;
      --green-seen: #07bc0c;
      --gray-light: #f5f7fa;
      --gray-medium: #e4e7eb;
      --gray-dark: #9aa4b2;
      --message-bg: #f1f3f4;
      --message-text: #202124;
      --sent-message-bg: var(--blue-primary);
      --sent-message-text: white;
      --deleted-message-bg: #f8f9fa;
      --deleted-message-text: #6c757d;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    }

    body {
      background-color: var(--bg-light);
      color: var(--text-gray);
      min-height: 100vh;
      padding: 0;
      margin: 0;
      touch-action: manipulation;
      overflow-x: hidden;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    /* Header */
    .chat-header {
      background: linear-gradient(120deg, var(--blue-primary), var(--blue-dark));
      color: white;
      padding: 16px 20px;
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: 0 4px 20px rgba(26, 115, 232, 0.22);
      display: flex;
      align-items: center;
    }

    .back-btn {
      background: none;
      border: none;
      color: white;
      font-size: 24px;
      margin-right: 16px;
      cursor: pointer;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
    }

    .back-btn:hover {
      background: rgba(255,255,255,0.2);
    }

    .header-info {
      flex: 1;
    }

    .recipient-name {
      font-weight: 600;
      font-size: 1.2rem;
      margin-bottom: 2px;
    }

    .online-status {
      display: flex;
      align-items: center;
      font-size: 0.85rem;
    }

    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 6px;
    }

    .online {
      background-color: var(--green-seen);
    }

    .offline {
      background-color: var(--gray-medium);
    }

    /* Chat Container */
    .chat-container {
      flex: 1;
      overflow-y: auto;
      padding: 20px 16px;
      display: flex;
      flex-direction: column;
      background-color: var(--gray-light);
    }

    /* Message Bubble */
    .message {
      max-width: 75%;
      padding: 10px 14px;
      margin-bottom: 12px;
      border-radius: 18px;
      position: relative;
      animation: fadeIn 0.2s ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .received {
      background-color: var(--message-bg);
      color: var(--message-text);
      align-self: flex-start;
      border-bottom-left-radius: 4px;
    }

    .sent {
      background-color: var(--sent-message-bg);
      color: var(--sent-message-text);
      align-self: flex-end;
      border-bottom-right-radius: 4px;
    }

    .deleted {
      background-color: var(--deleted-message-bg) !important;
      color: var(--deleted-message-text) !important;
      font-style: italic;
    }

    .message-text {
      font-size: 1rem;
      line-height: 1.4;
      word-wrap: break-word;
    }

    .reply-preview {
      background-color: rgba(0,0,0,0.05);
      padding: 6px 10px;
      border-radius: 10px;
      margin-bottom: 8px;
      font-size: 0.85rem;
      color: #5f6368;
    }

    .reply-preview.sent {
      background-color: rgba(255,255,255,0.2);
    }

    .reply-preview .reply-author {
      font-weight: 600;
      margin-right: 6px;
    }

    .message-time {
      font-size: 0.7rem;
      margin-top: 4px;
      opacity: 0.8;
    }

    .sent .message-time {
      color: rgba(255, 255, 255, 0.8);
    }

    .message-actions {
      position: absolute;
      top: -32px;
      right: 0;
      background: white;
      border-radius: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      padding: 4px 0;
      display: none;
      z-index: 10;
      min-width: 120px;
    }

    .message:hover .message-actions {
      display: block;
    }

    .action-item {
      padding: 8px 16px;
      font-size: 0.85rem;
      cursor: pointer;
      white-space: nowrap;
      display: flex;
      align-items: center;
    }

    .action-item:hover {
      background-color: var(--blue-light);
    }

    .action-icon {
      margin-right: 8px;
      font-size: 14px;
    }

    /* Typing Indicator */
    .typing-indicator {
      display: flex;
      align-items: center;
      padding: 10px 16px;
      background-color: var(--message-bg);
      border-radius: 18px;
      align-self: flex-start;
      margin-bottom: 12px;
      max-width: 120px;
    }

    .typing-dots {
      display: flex;
      margin-left: 8px;
    }

    .typing-dot {
      width: 6px;
      height: 6px;
      background: var(--gray-dark);
      border-radius: 50%;
      margin: 0 2px;
      animation: typing 1.4s infinite;
    }

    .typing-dot:nth-child(2) {
      animation-delay: 0.2s;
    }

    .typing-dot:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes typing {
      0%, 60%, 100% { transform: translateY(0); }
      30% { transform: translateY(-5px); }
    }

    /* Input Area */
    .input-area {
      background: white;
      padding: 12px 16px;
      display: flex;
      align-items: center;
      border-top: 1px solid var(--border-gray);
      position: sticky;
      bottom: 0;
      z-index: 100;
    }

    .replying-to {
      background: var(--blue-light);
      padding: 8px 12px;
      border-radius: 16px;
      margin-bottom: 10px;
      display: none;
      width: 100%;
    }

    .replying-to-content {
      font-size: 0.85rem;
      color: var(--blue-primary);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .replying-to-text {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 80%;
    }

    .cancel-reply {
      background: none;
      border: none;
      color: var(--blue-primary);
      font-weight: bold;
      cursor: pointer;
    }

    .message-input {
      flex: 1;
      border: 1px solid var(--border-gray);
      border-radius: 24px;
      padding: 12px 16px;
      font-size: 1rem;
      resize: none;
      height: 50px;
      max-height: 120px;
      outline: none;
      transition: border-color 0.2s;
    }

    .message-input:focus {
      border-color: var(--blue-primary);
    }

    .send-button {
      background: linear-gradient(135deg, var(--blue-primary), var(--blue-dark));
      color: white;
      border: none;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      margin-left: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 2px 6px rgba(26, 115, 232, 0.3);
    }

    .send-button:hover {
      transform: scale(1.05);
    }

    .send-button:active {
      transform: scale(0.95);
    }

    .send-icon {
      font-size: 20px;
    }

    /* Selection Mode */
    .selection-mode {
      background: white;
      padding: 12px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-top: 1px solid var(--border-gray);
      display: none;
    }

    .selection-info {
      font-weight: 600;
      color: var(--blue-primary);
    }

    .selection-actions {
      display: flex;
      gap: 12px;
    }

    .selection-btn {
      background: var(--blue-light);
      border: none;
      border-radius: 20px;
      padding: 6px 16px;
      font-weight: 600;
      color: var(--blue-primary);
      cursor: pointer;
    }

    .selection-btn.delete {
      background: rgba(234, 67, 53, 0.1);
      color: var(--red-badge);
    }

    /* Message Selection */
    .message.selected {
      outline: 2px solid var(--blue-primary);
      outline-offset: -2px;
    }

    /* Empty State */
    .empty-chat {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      padding: 40px 20px;
      text-align: center;
      color: #777;
    }

    .empty-chat h3 {
      color: var(--blue-primary);
      margin-bottom: 10px;
    }

    .empty-chat p {
      max-width: 300px;
      line-height: 1.5;
    }

    /* Loading Screen */
    .loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.96);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      backdrop-filter: blur(3px);
    }

    .loader {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(26,115,232,0.2);
      border-top-color: var(--blue-primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 16px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Alert Styles */
    .alert-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(26, 115, 232, 0.15);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      backdrop-filter: blur(8px);
    }

    .alert {
      background: white;
      border-radius: 20px;
      padding: 32px;
      width: 90%;
      max-width: 480px;
      text-align: center;
      box-shadow: 0 12px 40px rgba(26, 115, 232, 0.25);
      border: 2px solid var(--blue-light);
    }

    .alert h2 {
      color: var(--blue-primary);
      margin-bottom: 18px;
      font-family: 'Montserrat', sans-serif;
      font-weight: 800;
      font-size: 1.6rem;
    }

    .alert p {
      margin-bottom: 24px;
      line-height: 1.5;
      color: #444;
      font-size: 1rem;
    }

    .alert-buttons {
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    .alert-button {
      background: linear-gradient(135deg, var(--blue-primary), var(--blue-dark));
      color: white;
      border: none;
      padding: 12px 28px;
      border-radius: 12px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      flex: 1;
    }

    .alert-button.secondary {
      background: var(--gray-light);
      color: var(--text-gray);
    }

    .alert-button:hover {
      transform: scale(1.02);
      box-shadow: 0 4px 12px rgba(26, 115, 232, 0.3);
    }

    /* Delete Options Modal */
    .delete-options-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1001;
      display: none;
    }

    .delete-options-content {
      background: white;
      border-radius: 20px;
      padding: 24px;
      width: 90%;
      max-width: 400px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }

    .delete-options-content h3 {
      color: var(--blue-primary);
      margin-bottom: 16px;
      font-size: 1.4rem;
    }

    .delete-option {
      display: flex;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid var(--border-gray);
    }

    .delete-option:last-child {
      border-bottom: none;
    }

    .delete-option input {
      margin-right: 12px;
      width: 18px;
      height: 18px;
      accent-color: var(--blue-primary);
    }

    .delete-option label {
      flex: 1;
      font-size: 1rem;
      color: var(--text-gray);
    }

    .delete-option-description {
      font-size: 0.85rem;
      color: #666;
      margin-top: 4px;
      display: block;
    }

    .delete-options-actions {
      display: flex;
      gap: 12px;
      margin-top: 20px;
    }

    .delete-options-btn {
      flex: 1;
      padding: 12px;
      border-radius: 12px;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      border: none;
      transition: all 0.2s;
    }

    .delete-options-btn.cancel {
      background: var(--gray-light);
      color: var(--text-gray);
    }

    .delete-options-btn.delete {
      background: linear-gradient(135deg, var(--blue-primary), var(--blue-dark));
      color: white;
    }

    .delete-options-btn.delete:hover {
      transform: scale(1.02);
      box-shadow: 0 4px 12px rgba(26, 115, 232, 0.3);
    }
  </style>
</head>
<body>
  <div class="chat-header">
    <button class="back-btn" id="backBtn">‚Üê</button>
    <div class="header-info">
      <div class="recipient-name" id="recipientName">Loading...</div>
      <div class="online-status">
        <div class="status-indicator offline" id="statusIndicator"></div>
        <span id="statusText">Offline</span>
      </div>
    </div>
  </div>

  <div class="chat-container" id="chatContainer">
    <!-- Messages will be loaded here -->
  </div>

  <div class="selection-mode" id="selectionMode">
    <div class="selection-info" id="selectionInfo">0 selected</div>
    <div class="selection-actions">
      <button class="selection-btn delete" id="deleteSelected">Delete</button>
      <button class="selection-btn" id="cancelSelection">Cancel</button>
    </div>
  </div>

  <div class="input-area">
    <div class="replying-to" id="replyingTo">
      <div class="replying-to-content">
        <div class="replying-to-text" id="replyingToText">Replying to...</div>
        <button class="cancel-reply" id="cancelReply">‚úï</button>
      </div>
    </div>
    <textarea class="message-input" id="messageInput" placeholder="Type a message..."></textarea>
    <button class="send-button" id="sendButton">
      <span class="send-icon">‚û§</span>
    </button>
  </div>

  <!-- Delete Options Modal -->
  <div class="delete-options-modal" id="deleteOptionsModal">
    <div class="delete-options-content">
      <h3>Delete Message</h3>
      <div class="delete-option">
        <input type="radio" id="deleteForMe" name="deleteOption" checked>
        <label for="deleteForMe">
          Delete for me
          <span class="delete-option-description">Only you will see this message removed</span>
        </label>
      </div>
      <div class="delete-option">
        <input type="radio" id="deleteForEveryone" name="deleteOption">
        <label for="deleteForEveryone">
          Delete for everyone
          <span class="delete-option-description">Both you and the recipient will see this message removed</span>
        </label>
      </div>
      <div class="delete-options-actions">
        <button class="delete-options-btn cancel" id="cancelDelete">Cancel</button>
        <button class="delete-options-btn delete" id="confirmDelete">Delete</button>
      </div>
    </div>
  </div>

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/12.2.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/12.2.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/12.2.1/firebase-firestore-compat.js"></script>

  <script>
    // üîë Firebase Config
    const firebaseConfig = {
      apiKey: "AIzaSyCusJ_rFuOWwy1QFZedtyJr7igCeiIg3a0",
      authDomain: "my-sign-up-and-login.firebaseapp.com",
      projectId: "my-sign-up-and-login",
      storageBucket: "my-sign-up-and-login.firebasestorage.app",
      messagingSenderId: "1009128333653",
      appId: "1:1009128333653:web:15c1609ca3fbd4720c0fdc"
    };

    // Initialize Firebase
    const app = firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const ADMIN_EMAIL = "bluepay863@gmail.com";

    let currentUser = null;
    let recipient = null;
    let chatId = null;
    let messages = [];
    let selectedMessages = new Set();
    let isTyping = false;
    let typingTimeout = null;
    let isInitialized = false;
    let replyToMessage = null;
    let messageToDelete = null;
    let isOwnMessage = false;

    // DOM Elements
    const chatContainer = document.getElementById('chatContainer');
    const messageInput = document.getElementById('messageInput');
    const sendButton = document.getElementById('sendButton');
    const backBtn = document.getElementById('backBtn');
    const recipientNameEl = document.getElementById('recipientName');
    const statusIndicator = document.getElementById('statusIndicator');
    const statusText = document.getElementById('statusText');
    const selectionMode = document.getElementById('selectionMode');
    const selectionInfo = document.getElementById('selectionInfo');
    const deleteSelected = document.getElementById('deleteSelected');
    const cancelSelection = document.getElementById('cancelSelection');
    const replyingTo = document.getElementById('replyingTo');
    const replyingToText = document.getElementById('replyingToText');
    const cancelReply = document.getElementById('cancelReply');
    const deleteOptionsModal = document.getElementById('deleteOptionsModal');
    const deleteForMeRadio = document.getElementById('deleteForMe');
    const deleteForEveryoneRadio = document.getElementById('deleteForEveryone');
    const cancelDelete = document.getElementById('cancelDelete');
    const confirmDelete = document.getElementById('confirmDelete');

    // Show loading screen
    function showLoading() {
      if (document.getElementById('loadingScreen')) return;
      document.body.insertAdjacentHTML('beforeend', `
        <div class="loading-screen" id="loadingScreen">
          <div class="loader"></div>
          <div>Loading chat...</div>
        </div>
      `);
    }

    // Hide loading screen
    function hideLoading() {
      const el = document.getElementById('loadingScreen');
      if (el) el.remove();
    }

    // Show alert
    function showBeautifulAlert(title, message, callback = null) {
      // Remove existing alert if any
      const existingOverlay = document.querySelector('.alert-overlay');
      if (existingOverlay) existingOverlay.remove();
      
      const overlay = document.createElement('div');
      overlay.className = 'alert-overlay';
      const alertDiv = document.createElement('div');
      alertDiv.className = 'alert';
      alertDiv.innerHTML = `
        <h2>${title}</h2>
        <p>${message}</p>
        <button class="alert-button">${callback ? "OK" : "Close"}</button>
      `;
      overlay.appendChild(alertDiv);
      document.body.appendChild(overlay);

      const button = alertDiv.querySelector('.alert-button');
      button.addEventListener('click', () => {
        document.body.removeChild(overlay);
        if (callback) callback();
      });
      
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          document.body.removeChild(overlay);
          if (callback) callback();
        }
      });
    }

    // Show confirmation alert
    function showConfirmationAlert(title, message, onConfirm, onCancel) {
      const existingOverlay = document.querySelector('.alert-overlay');
      if (existingOverlay) existingOverlay.remove();
      
            const overlay = document.createElement('div');
      overlay.className = 'alert-overlay';
      const alertDiv = document.createElement('div');
      alertDiv.className = 'alert';
      alertDiv.innerHTML = `
        <h2>${title}</h2>
        <p>${message}</p>
        <div class="alert-buttons">
          <button class="alert-button secondary">Cancel</button>
          <button class="alert-button">Confirm</button>
        </div>
      `;
      overlay.appendChild(alertDiv);
      document.body.appendChild(overlay);

      const confirmBtn = alertDiv.querySelector('.alert-button:last-child');
      const cancelBtn = alertDiv.querySelector('.alert-button:first-child');
      
      confirmBtn.addEventListener('click', () => {
        document.body.removeChild(overlay);
        if (onConfirm) onConfirm();
      });
      
      cancelBtn.addEventListener('click', () => {
        document.body.removeChild(overlay);
        if (onCancel) onCancel();
      });
      
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          document.body.removeChild(overlay);
          if (onCancel) onCancel();
        }
      });
    }

    // Update online status
    function updateOnlineStatus() {
      if (!recipient) return;
      
      // In a real app, you would check the user's online status
      // For this demo, we'll simulate online status
      const isOnline = Math.random() > 0.3; // 70% chance of being online
      
      if (isOnline) {
        statusIndicator.className = 'status-indicator online';
        statusText.textContent = 'Online';
      } else {
        statusIndicator.className = 'status-indicator offline';
        statusText.textContent = 'Offline';
      }
    }

    // Setup online status listener
    function setupOnlineStatusListener() {
      // In a real app, you would listen to the user's presence
      // For this demo, we'll update every 30 seconds
      setInterval(updateOnlineStatus, 30000);
    }

    // Load messages
    async function loadMessages() {
      try {
        const messagesSnap = await db.collection('chats').doc(chatId).collection('messages')
          .orderBy('timestamp', 'asc')
          .get();
        
        messages = [];
        messagesSnap.forEach(doc => {
          messages.push({
            id: doc.id,
            ...doc.data()
          });
        });
        
        renderMessages();
      } catch (error) {
        console.error("Error loading messages:", error);
        showBeautifulAlert("Error", "Failed to load messages");
      }
    }

    // Render messages
    function renderMessages() {
      chatContainer.innerHTML = '';
      
      if (messages.length === 0) {
        chatContainer.innerHTML = `
          <div class="empty-chat">
            <h3>No messages yet</h3>
            <p>Send a message to start the conversation!</p>
          </div>
        `;
        return;
      }
      
      messages.forEach(msg => {
        const isSent = msg.senderId === currentUser.uid;
        const isRead = msg.readBy && msg.readBy.includes(recipient.uid);
        const time = formatTime(msg.timestamp);
        const isDeleted = msg.deletedFor && 
          (msg.deletedFor.includes(currentUser.uid) || msg.deletedFor.includes('everyone'));
        
        const messageEl = document.createElement('div');
        messageEl.className = `message ${isSent ? 'sent' : 'received'} ${isDeleted ? 'deleted' : ''}`;
        messageEl.dataset.messageId = msg.id;
        messageEl.dataset.senderId = msg.senderId;
        
        let messageContent = '';
        if (isDeleted) {
          messageContent = '<div class="message-text">This message was deleted</div>';
        } else {
          // Handle reply preview
          let replyPreview = '';
          if (msg.replyTo) {
            const repliedMsg = messages.find(m => m.id === msg.replyTo.messageId);
            if (repliedMsg && !repliedMsg.deletedFor) {
              const replyAuthor = repliedMsg.senderId === currentUser.uid ? 
                'You' : 
                (recipient.uid === repliedMsg.senderId ? recipientNameEl.textContent : 'Unknown');
              replyPreview = `
                <div class="reply-preview ${isSent ? 'sent' : 'received'}">
                  <span class="reply-author">${replyAuthor}:</span> 
                  ${repliedMsg.text}
                </div>
              `;
            }
          }
          
          messageContent = `
            ${replyPreview}
            <div class="message-text">${msg.text}</div>
          `;
        }
        
        messageEl.innerHTML = `
          ${messageContent}
          <div class="message-time">${time}${isSent && isRead && !isDeleted ? ' ‚úì‚úì' : ''}</div>
          ${!isDeleted ? `
            <div class="message-actions">
              <div class="action-item" data-action="reply">
                <span class="action-icon">‚Ü©Ô∏è</span> Reply
              </div>
              <div class="action-item" data-action="delete">
                <span class="action-icon">üóëÔ∏è</span> Delete
              </div>
            </div>
          ` : ''}
        `;
        
        // Add event listeners for actions
        const actions = messageEl.querySelectorAll('.action-item');
        actions.forEach(action => {
          action.addEventListener('click', (e) => {
            e.stopPropagation();
            const actionType = action.dataset.action;
            if (actionType === 'reply') {
              setReplyToMessage(msg);
            } else if (actionType === 'delete') {
              // Show delete options modal
              messageToDelete = msg.id;
              isOwnMessage = msg.senderId === currentUser.uid;
              
              // Update modal based on message ownership
              if (isOwnMessage) {
                deleteForEveryoneRadio.disabled = false;
                deleteForEveryoneRadio.parentElement.style.opacity = '1';
                deleteForEveryoneRadio.parentElement.style.pointerEvents = 'auto';
              } else {
                deleteForEveryoneRadio.disabled = true;
                deleteForEveryoneRadio.parentElement.style.opacity = '0.5';
                deleteForEveryoneRadio.parentElement.style.pointerEvents = 'none';
                deleteForMeRadio.checked = true;
              }
              
              deleteOptionsModal.style.display = 'flex';
            }
          });
        });
        
        // Add selection handler
        messageEl.addEventListener('click', (e) => {
          if (selectionMode.style.display === 'flex') {
            toggleMessageSelection(msg.id, messageEl);
          }
        });
        
        // Add long press for mobile
        let pressTimer;
        messageEl.addEventListener('touchstart', (e) => {
          pressTimer = setTimeout(() => {
            if (selectionMode.style.display !== 'flex') {
              // Show actions on long press
              const actions = messageEl.querySelector('.message-actions');
              if (actions) {
                actions.style.display = 'block';
                setTimeout(() => {
                  actions.style.display = 'none';
                }, 3000);
              }
            } else {
              toggleMessageSelection(msg.id, messageEl);
            }
          }, 500);
        });
        
        messageEl.addEventListener('touchend', () => {
          clearTimeout(pressTimer);
        });
        
        messageEl.addEventListener('touchmove', () => {
          clearTimeout(pressTimer);
        });
        
        chatContainer.appendChild(messageEl);
      });
      
      // Scroll to bottom
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    // Format timestamp
    function formatTime(timestamp) {
      if (!timestamp) return "";
      const date = new Date(timestamp.seconds ? timestamp.seconds * 1000 : timestamp);
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    // Set reply to message
    function setReplyToMessage(message) {
      replyToMessage = message;
      replyingToText.textContent = message.text.length > 30 ? 
        message.text.substring(0, 30) + '...' : 
        message.text;
      replyingTo.style.display = 'block';
      messageInput.focus();
    }

    // Cancel reply
    function cancelReplyToMessage() {
      replyToMessage = null;
      replyingTo.style.display = 'none';
    }

    // Handle sending message
    async function sendMessage() {
      const text = messageInput.value.trim();
      if (!text) return;
      
      try {
        const newMessage = {
          text: text,
          senderId: currentUser.uid,
          timestamp: firebase.firestore.FieldValue.serverTimestamp(),
          readBy: []
        };
        
        // Add reply reference if replying
        if (replyToMessage) {
          newMessage.replyTo = {
            messageId: replyToMessage.id,
            senderId: replyToMessage.senderId,
            text: replyToMessage.text
          };
          cancelReplyToMessage();
        }
        
        await db.collection('chats').doc(chatId).collection('messages').add(newMessage);
        messageInput.value = '';
        messageInput.style.height = '50px';
        
        // Scroll to bottom
        chatContainer.scrollTop = chatContainer.scrollHeight;
      } catch (error) {
        console.error("Error sending message:", error);
        showBeautifulAlert("Error", "Failed to send message");
      }
    }

    // Handle delete message based on selected option
    function handleDeleteMessage() {
      const deleteForEveryone = deleteForEveryoneRadio.checked;
      
      if (deleteForEveryone) {
        // Delete for everyone
        deleteMessageForEveryone(messageToDelete);
      } else {
        // Delete for me only
        deleteMessageForUser(messageToDelete, currentUser.uid);
      }
      
      // Close modal
      deleteOptionsModal.style.display = 'none';
    }

    // Delete message for current user only
    async function deleteMessageForUser(messageId, userId) {
      try {
        // Update the message to mark as deleted for this user
        await db.collection('chats').doc(chatId).collection('messages').doc(messageId).update({
          deletedFor: firebase.firestore.FieldValue.arrayUnion(userId)
        });
      } catch (error) {
        console.error("Error deleting message:", error);
        showBeautifulAlert("Error", "Failed to delete message");
      }
    }

    // Delete message for everyone
    async function deleteMessageForEveryone(messageId) {
      try {
        // Mark as deleted for everyone
        await db.collection('chats').doc(chatId).collection('messages').doc(messageId).update({
          deletedFor: ['everyone']
        });
      } catch (error) {
        console.error("Error deleting message:", error);
        showBeautifulAlert("Error", "Failed to delete message");
      }
    }

    // Setup message listener
    function setupMessageListener() {
      db.collection('chats').doc(chatId).collection('messages')
        .orderBy('timestamp', 'asc')
        .onSnapshot(snapshot => {
          snapshot.docChanges().forEach(change => {
            if (change.type === 'added') {
              const newMsg = {
                id: change.doc.id,
                ...change.doc.data()
              };
              
              // Mark as read if it's from the recipient
              if (newMsg.senderId === recipient.uid) {
                markMessageAsRead(newMsg.id);
              }
              
              messages.push(newMsg);
            }
            else if (change.type === 'modified') {
              const index = messages.findIndex(m => m.id === change.doc.id);
              if (index !== -1) {
                messages[index] = {
                  id: change.doc.id,
                  ...change.doc.data()
                };
              }
            }
            else if (change.type === 'removed') {
              const index = messages.findIndex(m => m.id === change.doc.id);
              if (index !== -1) {
                messages.splice(index, 1);
              }
            }
          });
          
          renderMessages();
        });
    }

    // Mark message as read
    async function markMessageAsRead(messageId) {
      try {
        await db.collection('chats').doc(chatId).collection('messages').doc(messageId).update({
          readBy: firebase.firestore.FieldValue.arrayUnion(currentUser.uid)
        });
      } catch (error) {
        console.error("Error marking message as read:", error);
      }
    }

    // Setup typing listener
    function setupTypingListener() {
      // Listen for typing indicators
      db.collection('chats').doc(chatId).collection('typing').doc(recipient.uid)
        .onSnapshot(doc => {
          if (doc.exists) {
            const data = doc.data();
            if (data.isTyping) {
              showTypingIndicator();
            } else {
              hideTypingIndicator();
            }
          } else {
            hideTypingIndicator();
          }
        });
    }

    // Show typing indicator
    function showTypingIndicator() {
      // Remove existing typing indicator
      const existing = document.querySelector('.typing-indicator');
      if (existing) existing.remove();
      
      // Create new typing indicator
      const indicator = document.createElement('div');
      indicator.className = 'typing-indicator';
      indicator.innerHTML = `
        <span>${recipient.email === ADMIN_EMAIL ? "BluePay Admin" : recipient.name}</span>
        <div class="typing-dots">
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
        </div>
      `;
      
      chatContainer.appendChild(indicator);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    // Hide typing indicator
    function hideTypingIndicator() {
      const existing = document.querySelector('.typing-indicator');
      if (existing) existing.remove();
    }

    // Send typing indicator
    async function sendTypingIndicator(isTyping) {
      try {
        await db.collection('chats').doc(chatId).collection('typing').doc(currentUser.uid).set({
          isTyping: isTyping,
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });
      } catch (error) {
        console.error("Error sending typing indicator:", error);
      }
    }

    // Toggle message selection
    function toggleMessageSelection(messageId, element) {
      if (selectedMessages.has(messageId)) {
        selectedMessages.delete(messageId);
        element.classList.remove('selected');
      } else {
        selectedMessages.add(messageId);
        element.classList.add('selected');
      }
      
      updateSelectionInfo();
    }

    // Update selection info
    function updateSelectionInfo() {
      const count = selectedMessages.size;
      selectionInfo.textContent = `${count} selected`;
      
      if (count > 0) {
        selectionMode.style.display = 'flex';
      } else {
        selectionMode.style.display = 'none';
      }
    }

    // Delete selected messages
    function deleteSelectedMessages() {
      if (selectedMessages.size === 0) return;
      
      showConfirmationAlert(
        "Delete selected messages?",
        `This will delete ${selectedMessages.size} message(s) for you only.`,
        async () => {
          // Delete each selected message for current user
          const promises = [];
          selectedMessages.forEach(messageId => {
            promises.push(deleteMessageForUser(messageId, currentUser.uid));
          });
          
          try {
            await Promise.all(promises);
            selectedMessages.clear();
            updateSelectionInfo();
          } catch (error) {
            console.error("Error deleting messages:", error);
            showBeautifulAlert("Error", "Failed to delete some messages");
          }
        },
        () => {}
      );
    }

    // Initialize chat
    async function initChat() {
      if (isInitialized) return;
      isInitialized = true;
      
      showLoading();
      
      // Get recipient from URL
      const urlParams = new URLSearchParams(window.location.search);
      const recipientId = urlParams.get('to');
      if (!recipientId) {
        hideLoading();
        showBeautifulAlert("Error", "Recipient not specified");
        return;
      }

      // Fetch recipient data
      try {
        const userDoc = await db.collection('users').doc(recipientId).get();
        if (!userDoc.exists) {
          hideLoading();
          showBeautifulAlert("Error", "User not found");
          return;
        }
        recipient = userDoc.data();
        recipient.uid = userDoc.id;
        
        // Set chat ID
        chatId = [currentUser.uid, recipient.uid].sort().join('_');
        
        // Update UI
        recipientNameEl.textContent = recipient.email === ADMIN_EMAIL ? "BluePay Admin" : recipient.name;
        updateOnlineStatus();
        
        // Load messages
        await loadMessages();
        hideLoading();
        
        // Setup listeners
        setupMessageListener();
        setupTypingListener();
        setupOnlineStatusListener();
        
        // Focus input
        messageInput.focus();
      } catch (error) {
        console.error("Error initializing chat:", error);
        hideLoading();
        showBeautifulAlert("Error", "Failed to load chat");
      }
    }

    // Initialize the app
    function init() {
      // Check if user is authenticated
      auth.onAuthStateChanged(user => {
        if (user) {
          currentUser = user;
          initChat();
        } else {
          // User is not signed in, redirect to login
          hideLoading();
          showBeautifulAlert("Authentication Required", "You need to be signed in to access this chat.", () => {
            window.location.href = 'login.html';
          });
        }
      });
    }

    // Event Listeners
    sendButton.addEventListener('click', sendMessage);
    
    messageInput.addEventListener('input', () => {
      // Auto-resize textarea
      messageInput.style.height = '50px';
      messageInput.style.height = Math.min(messageInput.scrollHeight, 120) + 'px';
      
      // Send typing indicator
      if (messageInput.value.trim() && !isTyping) {
        isTyping = true;
        sendTypingIndicator(true);
      }
      
      if (typingTimeout) clearTimeout(typingTimeout);
      typingTimeout = setTimeout(() => {
        if (isTyping) {
          isTyping = false;
          sendTypingIndicator(false);
        }
      }, 1000);
    });
    
    messageInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });
    
    backBtn.addEventListener('click', () => {
      // Go back to friends list
      window.location.href = 'friends.html';
    });
    
    deleteSelected.addEventListener('click', deleteSelectedMessages);
    cancelSelection.addEventListener('click', () => {
      selectedMessages.clear();
      updateSelectionInfo();
      document.querySelectorAll('.message').forEach(el => {
        el.classList.remove('selected');
      });
    });
    
    cancelReply.addEventListener('click', cancelReplyToMessage);
    
    // Delete modal event listeners
    cancelDelete.addEventListener('click', () => {
      deleteOptionsModal.style.display = 'none';
    });
    
    confirmDelete.addEventListener('click', handleDeleteMessage);
    
    // Close modal when clicking outside
    deleteOptionsModal.addEventListener('click', (e) => {
      if (e.target === deleteOptionsModal) {
        deleteOptionsModal.style.display = 'none';
      }
    });

        // Initialize when DOM is loaded
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>